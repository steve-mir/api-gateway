//! # Compliance Reporting for Admin Operations
//!
//! This module provides comprehensive compliance reporting capabilities for admin operations:
//! - Audit trail reporting for regulatory compliance
//! - Access control compliance reports
//! - Security incident reporting
//! - Data retention and archival policies
//! - Compliance dashboard and metrics
//! - Automated compliance checks

use crate::admin::audit::{ConfigAudit, ConfigChange};
use crate::core::error::{GatewayError, GatewayResult};

use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    response::Json,
    routing::{get, post},
    Router,
};
use chrono::{DateTime, Duration, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use uuid::Uuid;

// ============================================================================
// Compliance Framework Types
// ============================================================================

/// Compliance framework types
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ComplianceFramework {
    /// SOX (Sarbanes-Oxley Act)
    Sox,
    /// GDPR (General Data Protection Regulation)
    Gdpr,
    /// HIPAA (Health Insurance Portability and Accountability Act)
    Hipaa,
    /// PCI DSS (Payment Card Industry Data Security Standard)
    PciDss,
    /// ISO 27001
    Iso27001,
    /// NIST Cybersecurity Framework
    NistCsf,
    /// Custom compliance framework
    Custom(String),
}

/// Compliance requirement
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComplianceRequirement {
    /// Requirement ID
    pub id: String,
    /// Framework this requirement belongs to
    pub framework: ComplianceFramework,
    /// Requirement title
    pub title: String,
    /// Detailed description
    pub description: String,
    /// Control category
    pub category: String,
    /// Severity level
    pub severity: ComplianceSeverity,
    /// Implementation status
    pub status: ComplianceStatus,
    /// Evidence required
    pub evidence_required: Vec<EvidenceType>,
    /// Automated check available
    pub automated_check: bool,
    /// Last assessment date
    pub last_assessed: Option<DateTime<Utc>>,
    /// Next assessment due
    pub next_assessment: Option<DateTime<Utc>>,
}

/// Compliance severity levels
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ComplianceSeverity {
    Critical,
    High,
    Medium,
    Low,
}

/// Compliance status
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ComplianceStatus {
    Compliant,
    NonCompliant,
    PartiallyCompliant,
    NotAssessed,
    NotApplicable,
}

/// Types of evidence for compliance
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum EvidenceType {
    /// Audit logs
    AuditLogs,
    /// Access control records
    AccessControlRecords,
    /// Configuration snapshots
    ConfigurationSnapshots,
    /// Security scan results
    SecurityScanResults,
    /// Training records
    TrainingRecords,
    /// Policy documents
    PolicyDocuments,
    /// Incident reports
    IncidentReports,
    /// Risk assessments
    RiskAssessments,
}

/// Compliance report
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComplianceReport {
    /// Report ID
    pub id: Uuid,
    /// Report type
    pub report_type: ComplianceReportType,
    /// Framework being reported on
    pub framework: ComplianceFramework,
    /// Report period
    pub period: ReportPeriod,
    /// Report generation time
    pub generated_at: DateTime<Utc>,
    /// Generated by user
    pub generated_by: String,
    /// Report status
    pub status: ReportStatus,
    /// Executive summary
    pub executive_summary: ExecutiveSummary,
    /// Detailed findings
    pub findings: Vec<ComplianceFinding>,
    /// Recommendations
    pub recommendations: Vec<ComplianceRecommendation>,
    /// Evidence collected
    pub evidence: Vec<ComplianceEvidence>,
    /// Report metadata
    pub metadata: HashMap<String, serde_json::Value>,
}

/// Types of compliance reports
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ComplianceReportType {
    /// Regular periodic report
    Periodic,
    /// Incident-driven report
    Incident,
    /// Audit preparation report
    AuditPreparation,
    /// Risk assessment report
    RiskAssessment,
    /// Control effectiveness report
    ControlEffectiveness,
    /// Data breach notification
    DataBreachNotification,
}

/// Report period specification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReportPeriod {
    /// Start date
    pub start_date: DateTime<Utc>,
    /// End date
    pub end_date: DateTime<Utc>,
    /// Period description
    pub description: String,
}

/// Report status
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ReportStatus {
    Draft,
    InReview,
    Approved,
    Published,
    Archived,
}

/// Executive summary of compliance report
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutiveSummary {
    /// Overall compliance score (0-100)
    pub overall_score: f64,
    /// Total requirements assessed
    pub total_requirements: u32,
    /// Compliant requirements
    pub compliant_requirements: u32,
    /// Non-compliant requirements
    pub non_compliant_requirements: u32,
    /// Key risks identified
    pub key_risks: Vec<String>,
    /// Critical findings count
    pub critical_findings: u32,
    /// High priority findings count
    pub high_priority_findings: u32,
    /// Improvement trend
    pub improvement_trend: ImprovementTrend,
}

/// Improvement trend
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ImprovementTrend {
    Improving,
    Stable,
    Declining,
    Unknown,
}

/// Compliance finding
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComplianceFinding {
    /// Finding ID
    pub id: Uuid,
    /// Requirement this finding relates to
    pub requirement_id: String,
    /// Finding type
    pub finding_type: FindingType,
    /// Severity level
    pub severity: ComplianceSeverity,
    /// Finding title
    pub title: String,
    /// Detailed description
    pub description: String,
    /// Evidence supporting this finding
    pub evidence_ids: Vec<Uuid>,
    /// Impact assessment
    pub impact: String,
    /// Likelihood assessment
    pub likelihood: String,
    /// Risk score
    pub risk_score: f64,
    /// Status
    pub status: FindingStatus,
    /// Assigned to
    pub assigned_to: Option<String>,
    /// Due date for remediation
    pub due_date: Option<DateTime<Utc>>,
    /// Discovery date
    pub discovered_at: DateTime<Utc>,
}

/// Types of compliance findings
#[derive(Debug, Clone, Serialize, Deserialize, Eq, Hash, PartialEq)]
pub enum FindingType {
    /// Control deficiency
    ControlDeficiency,
    /// Policy violation
    PolicyViolation,
    /// Configuration issue
    ConfigurationIssue,
    /// Access control violation
    AccessControlViolation,
    /// Data handling issue
    DataHandlingIssue,
    /// Security vulnerability
    SecurityVulnerability,
    /// Audit trail gap
    AuditTrailGap,
}

/// Finding status
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FindingStatus {
    Open,
    InProgress,
    Resolved,
    Accepted,
    Deferred,
}

/// Compliance recommendation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComplianceRecommendation {
    /// Recommendation ID
    pub id: Uuid,
    /// Related finding IDs
    pub finding_ids: Vec<Uuid>,
    /// Recommendation title
    pub title: String,
    /// Detailed description
    pub description: String,
    /// Priority level
    pub priority: RecommendationPriority,
    /// Estimated effort
    pub estimated_effort: String,
    /// Expected impact
    pub expected_impact: String,
    /// Implementation timeline
    pub timeline: String,
    /// Responsible party
    pub responsible_party: Option<String>,
    /// Status
    pub status: RecommendationStatus,
}

/// Recommendation priority
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RecommendationPriority {
    Critical,
    High,
    Medium,
    Low,
}

/// Recommendation status
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RecommendationStatus {
    Proposed,
    Approved,
    InProgress,
    Completed,
    Rejected,
}

/// Compliance evidence
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComplianceEvidence {
    /// Evidence ID
    pub id: Uuid,
    /// Evidence type
    pub evidence_type: EvidenceType,
    /// Evidence title
    pub title: String,
    /// Description
    pub description: String,
    /// Collection date
    pub collected_at: DateTime<Utc>,
    /// Collected by
    pub collected_by: String,
    /// Data source
    pub source: String,
    /// Evidence data (could be file path, database query result, etc.)
    pub data: serde_json::Value,
    /// Hash for integrity verification
    pub hash: String,
    /// Retention period
    pub retention_period: Duration,
    /// Expiration date
    pub expires_at: DateTime<Utc>,
}

// ============================================================================
// Compliance Manager
// ============================================================================

/// Compliance reporting and management system
pub struct ComplianceManager {
    /// Compliance requirements database
    requirements: Arc<RwLock<HashMap<String, ComplianceRequirement>>>,
    /// Generated reports
    reports: Arc<RwLock<HashMap<Uuid, ComplianceReport>>>,
    /// Evidence store
    evidence_store: Arc<RwLock<HashMap<Uuid, ComplianceEvidence>>>,
    /// Audit trail reference
    audit: Arc<ConfigAudit>,
}

impl ComplianceManager {
    pub fn new(audit: Arc<ConfigAudit>) -> Self {
        let manager = Self {
            requirements: Arc::new(RwLock::new(HashMap::new())),
            reports: Arc::new(RwLock::new(HashMap::new())),
            evidence_store: Arc::new(RwLock::new(HashMap::new())),
            audit,
        };

        // Initialize default compliance requirements
        tokio::spawn({
            let manager = manager.clone();
            async move {
                if let Err(e) = manager.initialize_default_requirements().await {
                    tracing::error!("Failed to initialize compliance requirements: {}", e);
                }
            }
        });

        manager
    }

    /// Generate compliance report
    pub async fn generate_report(
        &self,
        report_type: ComplianceReportType,
        framework: ComplianceFramework,
        period: ReportPeriod,
        generated_by: String,
    ) -> GatewayResult<Uuid> {
        let report_id = Uuid::new_v4();
        
        // Collect evidence
        let evidence = self.collect_evidence(&framework, &period).await?;
        
        // Assess compliance
        let findings = self.assess_compliance(&framework, &period, &evidence).await?;
        
        // Generate recommendations
        let recommendations = self.generate_recommendations(&findings).await?;
        
        // Create executive summary
        let executive_summary = self.create_executive_summary(&findings).await?;
        
        let report = ComplianceReport {
            id: report_id,
            report_type,
            framework,
            period,
            generated_at: Utc::now(),
            generated_by,
            status: ReportStatus::Draft,
            executive_summary,
            findings,
            recommendations,
            evidence,
            metadata: HashMap::new(),
        };

        let mut reports = self.reports.write().await;
        reports.insert(report_id, report.clone());

        tracing::info!(
            report_id = %report_id,
            framework = ?report.framework,
            "Compliance report generated"
        );

        Ok(report_id)
    }

    /// Collect evidence for compliance assessment
    async fn collect_evidence(
        &self,
        framework: &ComplianceFramework,
        period: &ReportPeriod,
    ) -> GatewayResult<Vec<ComplianceEvidence>> {
        let mut evidence = Vec::new();

        // Collect audit logs
        let audit_stats = self.audit.get_statistics().await;
        evidence.push(ComplianceEvidence {
            id: Uuid::new_v4(),
            evidence_type: EvidenceType::AuditLogs,
            title: "Admin Operation Audit Logs".to_string(),
            description: format!("Audit logs for period {} to {}", period.start_date, period.end_date),
            collected_at: Utc::now(),
            collected_by: "system".to_string(),
            source: "admin_audit_trail".to_string(),
            data: serde_json::to_value(&audit_stats)?,
            hash: self.calculate_hash(&serde_json::to_string(&audit_stats)?),
            retention_period: Duration::days(2555), // 7 years
            expires_at: Utc::now() + Duration::days(2555),
        });

        // Collect configuration snapshots
        let config_changes = self.audit.get_records_paginated(0, 1000).await;
        evidence.push(ComplianceEvidence {
            id: Uuid::new_v4(),
            evidence_type: EvidenceType::ConfigurationSnapshots,
            title: "Configuration Changes".to_string(),
            description: "Configuration changes during the reporting period".to_string(),
            collected_at: Utc::now(),
            collected_by: "system".to_string(),
            source: "config_audit_trail".to_string(),
            data: serde_json::to_value(&config_changes)?,
            hash: self.calculate_hash(&serde_json::to_string(&config_changes)?),
            retention_period: Duration::days(2555),
            expires_at: Utc::now() + Duration::days(2555),
        });

        // Framework-specific evidence collection
        match framework {
            ComplianceFramework::Sox => {
                evidence.extend(self.collect_sox_evidence(period).await?);
            }
            ComplianceFramework::Gdpr => {
                evidence.extend(self.collect_gdpr_evidence(period).await?);
            }
            ComplianceFramework::PciDss => {
                evidence.extend(self.collect_pci_evidence(period).await?);
            }
            _ => {
                // Generic evidence collection
            }
        }

        Ok(evidence)
    }

    /// Collect SOX-specific evidence
    async fn collect_sox_evidence(&self, _period: &ReportPeriod) -> GatewayResult<Vec<ComplianceEvidence>> {
        let mut evidence = Vec::new();

        // SOX requires strong access controls and audit trails
        evidence.push(ComplianceEvidence {
            id: Uuid::new_v4(),
            evidence_type: EvidenceType::AccessControlRecords,
            title: "SOX Access Control Matrix".to_string(),
            description: "Access control records for financial system access".to_string(),
            collected_at: Utc::now(),
            collected_by: "system".to_string(),
            source: "access_control_system".to_string(),
            data: serde_json::json!({
                "access_reviews_completed": true,
                "segregation_of_duties": true,
                "privileged_access_monitored": true
            }),
            hash: "sox_access_control_hash".to_string(),
            retention_period: Duration::days(2555),
            expires_at: Utc::now() + Duration::days(2555),
        });

        Ok(evidence)
    }

    /// Collect GDPR-specific evidence
    async fn collect_gdpr_evidence(&self, _period: &ReportPeriod) -> GatewayResult<Vec<ComplianceEvidence>> {
        let mut evidence = Vec::new();

        // GDPR requires data processing records
        evidence.push(ComplianceEvidence {
            id: Uuid::new_v4(),
            evidence_type: EvidenceType::PolicyDocuments,
            title: "GDPR Data Processing Records".to_string(),
            description: "Records of personal data processing activities".to_string(),
            collected_at: Utc::now(),
            collected_by: "system".to_string(),
            source: "data_processing_system".to_string(),
            data: serde_json::json!({
                "data_subject_requests": 0,
                "data_breaches": 0,
                "privacy_impact_assessments": 1,
                "consent_management": true
            }),
            hash: "gdpr_processing_hash".to_string(),
            retention_period: Duration::days(2555),
            expires_at: Utc::now() + Duration::days(2555),
        });

        Ok(evidence)
    }

    /// Collect PCI DSS-specific evidence
    async fn collect_pci_evidence(&self, _period: &ReportPeriod) -> GatewayResult<Vec<ComplianceEvidence>> {
        let mut evidence = Vec::new();

        // PCI DSS requires security controls evidence
        evidence.push(ComplianceEvidence {
            id: Uuid::new_v4(),
            evidence_type: EvidenceType::SecurityScanResults,
            title: "PCI DSS Security Scans".to_string(),
            description: "Vulnerability scans and penetration test results".to_string(),
            collected_at: Utc::now(),
            collected_by: "system".to_string(),
            source: "security_scanner".to_string(),
            data: serde_json::json!({
                "vulnerability_scans_passed": true,
                "penetration_tests_passed": true,
                "network_segmentation_verified": true,
                "encryption_verified": true
            }),
            hash: "pci_security_hash".to_string(),
            retention_period: Duration::days(1095), // 3 years
            expires_at: Utc::now() + Duration::days(1095),
        });

        Ok(evidence)
    }

    /// Assess compliance against requirements
    async fn assess_compliance(
        &self,
        framework: &ComplianceFramework,
        _period: &ReportPeriod,
        evidence: &[ComplianceEvidence],
    ) -> GatewayResult<Vec<ComplianceFinding>> {
        let mut findings = Vec::new();
        let requirements = self.requirements.read().await;

        // Filter requirements by framework
        let framework_requirements: Vec<_> = requirements.values()
            .filter(|req| std::mem::discriminant(&req.framework) == std::mem::discriminant(framework))
            .collect();

        for requirement in framework_requirements {
            // Check if we have sufficient evidence for this requirement
            let relevant_evidence: Vec<_> = evidence.iter()
                .filter(|e| requirement.evidence_required.contains(&e.evidence_type))
                .collect();

            if relevant_evidence.is_empty() {
                findings.push(ComplianceFinding {
                    id: Uuid::new_v4(),
                    requirement_id: requirement.id.clone(),
                    finding_type: FindingType::AuditTrailGap,
                    severity: requirement.severity.clone(),
                    title: format!("Missing evidence for {}", requirement.title),
                    description: format!("No evidence found for requirement: {}", requirement.description),
                    evidence_ids: Vec::new(),
                    impact: "Cannot verify compliance with requirement".to_string(),
                    likelihood: "High".to_string(),
                    risk_score: 7.5,
                    status: FindingStatus::Open,
                    assigned_to: None,
                    due_date: Some(Utc::now() + Duration::days(30)),
                    discovered_at: Utc::now(),
                });
            } else {
                // Perform automated checks if available
                if requirement.automated_check {
                    if let Some(finding) = self.perform_automated_check(requirement, &relevant_evidence).await? {
                        findings.push(finding);
                    }
                }
            }
        }

        // Check for specific compliance violations based on audit data
        let audit_findings = self.check_audit_compliance(framework).await?;
        findings.extend(audit_findings);

        Ok(findings)
    }

    /// Perform automated compliance check
    async fn perform_automated_check(
        &self,
        requirement: &ComplianceRequirement,
        evidence: &[&ComplianceEvidence],
    ) -> GatewayResult<Option<ComplianceFinding>> {
        // Example automated checks based on requirement category
        match requirement.category.as_str() {
            "access_control" => {
                // Check for access control violations
                for evidence_item in evidence {
                    if let Some(violations) = evidence_item.data.get("access_violations") {
                        if violations.as_u64().unwrap_or(0) > 0 {
                            return Ok(Some(ComplianceFinding {
                                id: Uuid::new_v4(),
                                requirement_id: requirement.id.clone(),
                                finding_type: FindingType::AccessControlViolation,
                                severity: ComplianceSeverity::High,
                                title: "Access control violations detected".to_string(),
                                description: format!("Found {} access control violations", violations),
                                evidence_ids: vec![evidence_item.id],
                                impact: "Unauthorized access possible".to_string(),
                                likelihood: "Medium".to_string(),
                                risk_score: 6.5,
                                status: FindingStatus::Open,
                                assigned_to: None,
                                due_date: Some(Utc::now() + Duration::days(7)),
                                discovered_at: Utc::now(),
                            }));
                        }
                    }
                }
            }
            "audit_logging" => {
                // Check for audit logging gaps
                let audit_stats = self.audit.get_statistics().await;
                if audit_stats.failed_changes > 0 {
                    return Ok(Some(ComplianceFinding {
                        id: Uuid::new_v4(),
                        requirement_id: requirement.id.clone(),
                        finding_type: FindingType::AuditTrailGap,
                        severity: ComplianceSeverity::Medium,
                        title: "Failed configuration changes detected".to_string(),
                        description: format!("Found {} failed configuration changes", audit_stats.failed_changes),
                        evidence_ids: evidence.iter().map(|e| e.id).collect(),
                        impact: "Incomplete audit trail".to_string(),
                        likelihood: "Low".to_string(),
                        risk_score: 4.0,
                        status: FindingStatus::Open,
                        assigned_to: None,
                        due_date: Some(Utc::now() + Duration::days(14)),
                        discovered_at: Utc::now(),
                    }));
                }
            }
            _ => {
                // Generic compliance check
            }
        }

        Ok(None)
    }

    /// Check audit data for compliance violations
    async fn check_audit_compliance(&self, framework: &ComplianceFramework) -> GatewayResult<Vec<ComplianceFinding>> {
        let mut findings = Vec::new();
        let audit_records = self.audit.get_all_records().await;

        match framework {
            ComplianceFramework::Sox => {
                // SOX requires segregation of duties
                let user_changes: HashMap<String, Vec<&ConfigChange>> = audit_records.iter()
                    .fold(HashMap::new(), |mut acc, change| {
                        acc.entry(change.changed_by.clone()).or_default().push(change);
                        acc
                    });

                for (user, changes) in user_changes {
                    if changes.len() > 10 {
                        findings.push(ComplianceFinding {
                            id: Uuid::new_v4(),
                            requirement_id: "SOX_404".to_string(),
                            finding_type: FindingType::PolicyViolation,
                            severity: ComplianceSeverity::High,
                            title: "Potential segregation of duties violation".to_string(),
                            description: format!("User {} made {} changes, may violate SOD", user, changes.len()),
                            evidence_ids: Vec::new(),
                            impact: "SOX compliance risk".to_string(),
                            likelihood: "Medium".to_string(),
                            risk_score: 6.0,
                            status: FindingStatus::Open,
                            assigned_to: None,
                            due_date: Some(Utc::now() + Duration::days(7)),
                            discovered_at: Utc::now(),
                        });
                    }
                }
            }
            ComplianceFramework::Gdpr => {
                // GDPR requires data processing to be logged
                let data_processing_changes = audit_records.iter()
                    .filter(|change| change.description.contains("user") || change.description.contains("data"))
                    .count();

                if data_processing_changes == 0 {
                    findings.push(ComplianceFinding {
                        id: Uuid::new_v4(),
                        requirement_id: "GDPR_30".to_string(),
                        finding_type: FindingType::AuditTrailGap,
                        severity: ComplianceSeverity::Medium,
                        title: "No data processing activities logged".to_string(),
                        description: "No evidence of data processing activity logging".to_string(),
                        evidence_ids: Vec::new(),
                        impact: "GDPR compliance gap".to_string(),
                        likelihood: "Low".to_string(),
                        risk_score: 4.5,
                        status: FindingStatus::Open,
                        assigned_to: None,
                        due_date: Some(Utc::now() + Duration::days(30)),
                        discovered_at: Utc::now(),
                    });
                }
            }
            _ => {
                // Generic compliance checks
            }
        }

        Ok(findings)
    }

    /// Generate recommendations based on findings
    async fn generate_recommendations(&self, findings: &[ComplianceFinding]) -> GatewayResult<Vec<ComplianceRecommendation>> {
        let mut recommendations = Vec::new();

        // Group findings by type
        let mut findings_by_type: HashMap<FindingType, Vec<&ComplianceFinding>> = HashMap::new();
        for finding in findings {
            findings_by_type.entry(finding.finding_type.clone()).or_default().push(finding);
        }

        for (finding_type, type_findings) in findings_by_type {
            let recommendation = match finding_type {
                FindingType::AccessControlViolation => {
                    ComplianceRecommendation {
                        id: Uuid::new_v4(),
                        finding_ids: type_findings.iter().map(|f| f.id).collect(),
                        title: "Strengthen Access Controls".to_string(),
                        description: "Implement additional access control measures and regular reviews".to_string(),
                        priority: RecommendationPriority::High,
                        estimated_effort: "2-4 weeks".to_string(),
                        expected_impact: "Reduce access control violations by 90%".to_string(),
                        timeline: "30 days".to_string(),
                        responsible_party: Some("Security Team".to_string()),
                        status: RecommendationStatus::Proposed,
                    }
                }
                FindingType::AuditTrailGap => {
                    ComplianceRecommendation {
                        id: Uuid::new_v4(),
                        finding_ids: type_findings.iter().map(|f| f.id).collect(),
                        title: "Enhance Audit Logging".to_string(),
                        description: "Implement comprehensive audit logging for all admin operations".to_string(),
                        priority: RecommendationPriority::Medium,
                        estimated_effort: "1-2 weeks".to_string(),
                        expected_impact: "Complete audit trail coverage".to_string(),
                        timeline: "14 days".to_string(),
                        responsible_party: Some("Platform Team".to_string()),
                        status: RecommendationStatus::Proposed,
                    }
                }
                FindingType::PolicyViolation => {
                    ComplianceRecommendation {
                        id: Uuid::new_v4(),
                        finding_ids: type_findings.iter().map(|f| f.id).collect(),
                        title: "Policy Training and Enforcement".to_string(),
                        description: "Conduct policy training and implement automated enforcement".to_string(),
                        priority: RecommendationPriority::High,
                        estimated_effort: "3-6 weeks".to_string(),
                        expected_impact: "Reduce policy violations by 80%".to_string(),
                        timeline: "45 days".to_string(),
                        responsible_party: Some("Compliance Team".to_string()),
                        status: RecommendationStatus::Proposed,
                    }
                }
                _ => {
                    ComplianceRecommendation {
                        id: Uuid::new_v4(),
                        finding_ids: type_findings.iter().map(|f| f.id).collect(),
                        title: "Address Compliance Finding".to_string(),
                        description: "Review and address the identified compliance issue".to_string(),
                        priority: RecommendationPriority::Medium,
                        estimated_effort: "1-3 weeks".to_string(),
                        expected_impact: "Resolve compliance gap".to_string(),
                        timeline: "21 days".to_string(),
                        responsible_party: None,
                        status: RecommendationStatus::Proposed,
                    }
                }
            };

            recommendations.push(recommendation);
        }

        Ok(recommendations)
    }

    /// Create executive summary
    async fn create_executive_summary(&self, findings: &[ComplianceFinding]) -> GatewayResult<ExecutiveSummary> {
        let total_requirements = {
            let requirements = self.requirements.read().await;
            requirements.len() as u32
        };

        let critical_findings = findings.iter()
            .filter(|f| matches!(f.severity, ComplianceSeverity::Critical))
            .count() as u32;

        let high_priority_findings = findings.iter()
            .filter(|f| matches!(f.severity, ComplianceSeverity::High))
            .count() as u32;

        let non_compliant_requirements = findings.len() as u32;
        let compliant_requirements = total_requirements.saturating_sub(non_compliant_requirements);

        let overall_score = if total_requirements > 0 {
            (compliant_requirements as f64 / total_requirements as f64) * 100.0
        } else {
            100.0
        };

        let key_risks = findings.iter()
            .filter(|f| matches!(f.severity, ComplianceSeverity::Critical | ComplianceSeverity::High))
            .map(|f| f.title.clone())
            .take(5)
            .collect();

        Ok(ExecutiveSummary {
            overall_score,
            total_requirements,
            compliant_requirements,
            non_compliant_requirements,
            key_risks,
            critical_findings,
            high_priority_findings,
            improvement_trend: ImprovementTrend::Unknown, // Would be calculated from historical data
        })
    }

    /// Calculate hash for evidence integrity
    fn calculate_hash(&self, data: &str) -> String {
        use sha2::{Digest, Sha256};
        let mut hasher = Sha256::new();
        hasher.update(data.as_bytes());
        format!("{:x}", hasher.finalize())
    }

    /// Initialize default compliance requirements
    async fn initialize_default_requirements(&self) -> GatewayResult<()> {
        let mut requirements = self.requirements.write().await;

        // SOX requirements
        requirements.insert("SOX_404".to_string(), ComplianceRequirement {
            id: "SOX_404".to_string(),
            framework: ComplianceFramework::Sox,
            title: "Management Assessment of Internal Controls".to_string(),
            description: "Management must assess the effectiveness of internal controls over financial reporting".to_string(),
            category: "access_control".to_string(),
            severity: ComplianceSeverity::Critical,
            status: ComplianceStatus::NotAssessed,
            evidence_required: vec![EvidenceType::AccessControlRecords, EvidenceType::AuditLogs],
            automated_check: true,
            last_assessed: None,
            next_assessment: Some(Utc::now() + Duration::days(90)),
        });

        // GDPR requirements
        requirements.insert("GDPR_30".to_string(), ComplianceRequirement {
            id: "GDPR_30".to_string(),
            framework: ComplianceFramework::Gdpr,
            title: "Records of Processing Activities".to_string(),
            description: "Maintain records of all personal data processing activities".to_string(),
            category: "data_processing".to_string(),
            severity: ComplianceSeverity::High,
            status: ComplianceStatus::NotAssessed,
            evidence_required: vec![EvidenceType::AuditLogs, EvidenceType::PolicyDocuments],
            automated_check: true,
            last_assessed: None,
            next_assessment: Some(Utc::now() + Duration::days(30)),
        });

        // PCI DSS requirements
        requirements.insert("PCI_2".to_string(), ComplianceRequirement {
            id: "PCI_2".to_string(),
            framework: ComplianceFramework::PciDss,
            title: "Do not use vendor-supplied defaults for system passwords".to_string(),
            description: "Change all vendor-supplied defaults and remove or disable unnecessary default accounts".to_string(),
            category: "authentication".to_string(),
            severity: ComplianceSeverity::High,
            status: ComplianceStatus::NotAssessed,
            evidence_required: vec![EvidenceType::SecurityScanResults, EvidenceType::ConfigurationSnapshots],
            automated_check: true,
            last_assessed: None,
            next_assessment: Some(Utc::now() + Duration::days(90)),
        });

        Ok(())
    }

    /// Get compliance report
    pub async fn get_report(&self, report_id: Uuid) -> Option<ComplianceReport> {
        let reports = self.reports.read().await;
        reports.get(&report_id).cloned()
    }

    /// List compliance reports
    pub async fn list_reports(&self, limit: usize) -> Vec<ComplianceReport> {
        let reports = self.reports.read().await;
        reports.values().take(limit).cloned().collect()
    }

    /// Update report status
    pub async fn update_report_status(&self, report_id: Uuid, status: ReportStatus) -> GatewayResult<()> {
        let mut reports = self.reports.write().await;
        if let Some(report) = reports.get_mut(&report_id) {
            report.status = status;
            tracing::info!(report_id = %report_id, status = ?report.status, "Report status updated");
        }
        Ok(())
    }

    /// Get compliance dashboard data
    pub async fn get_dashboard_data(&self) -> GatewayResult<ComplianceDashboard> {
        let requirements = self.requirements.read().await;
        let reports = self.reports.read().await;

        let total_requirements = requirements.len();
        let compliant_requirements = requirements.values()
            .filter(|r| matches!(r.status, ComplianceStatus::Compliant))
            .count();

        let recent_reports: Vec<_> = reports.values()
            .filter(|r| Utc::now() - r.generated_at < Duration::days(30))
            .cloned()
            .collect();

        let critical_findings = recent_reports.iter()
            .flat_map(|r| &r.findings)
            .filter(|f| matches!(f.severity, ComplianceSeverity::Critical))
            .count();

        Ok(ComplianceDashboard {
            total_requirements,
            compliant_requirements,
            compliance_score: if total_requirements > 0 {
                (compliant_requirements as f64 / total_requirements as f64) * 100.0
            } else {
                100.0
            },
            recent_reports: recent_reports.len(),
            critical_findings,
            overdue_assessments: requirements.values()
                .filter(|r| r.next_assessment.map_or(false, |d| d < Utc::now()))
                .count(),
        })
    }
}

impl Clone for ComplianceManager {
    fn clone(&self) -> Self {
        Self {
            requirements: self.requirements.clone(),
            reports: self.reports.clone(),
            evidence_store: self.evidence_store.clone(),
            audit: self.audit.clone(),
        }
    }
}

/// Compliance dashboard data
#[derive(Debug, Serialize)]
pub struct ComplianceDashboard {
    pub total_requirements: usize,
    pub compliant_requirements: usize,
    pub compliance_score: f64,
    pub recent_reports: usize,
    pub critical_findings: usize,
    pub overdue_assessments: usize,
}

// ============================================================================
// Compliance State and Router
// ============================================================================

/// Compliance manager state
#[derive(Clone)]
pub struct ComplianceState {
    pub manager: ComplianceManager,
}

impl ComplianceState {
    pub fn new(audit: Arc<ConfigAudit>) -> Self {
        Self {
            manager: ComplianceManager::new(audit),
        }
    }
}

/// Create compliance router
pub fn create_compliance_router(state: ComplianceState) -> Router {
    Router::new()
        // Report management
        .route("/reports", post(generate_compliance_report))
        .route("/reports", get(list_compliance_reports))
        .route("/reports/:report_id", get(get_compliance_report))
        .route("/reports/:report_id/status", post(update_report_status))
        
        // Dashboard
        .route("/dashboard", get(get_compliance_dashboard))
        
        // Requirements
        .route("/requirements", get(list_compliance_requirements))
        .route("/requirements/:requirement_id", get(get_compliance_requirement))
        
        .with_state(state)
}

// ============================================================================
// Request/Response Types
// ============================================================================

#[derive(Debug, Deserialize)]
pub struct GenerateReportRequest {
    pub report_type: ComplianceReportType,
    pub framework: ComplianceFramework,
    pub start_date: DateTime<Utc>,
    pub end_date: DateTime<Utc>,
    pub period_description: String,
}

#[derive(Debug, Serialize)]
pub struct GenerateReportResponse {
    pub report_id: Uuid,
    pub status: ReportStatus,
    pub generated_at: DateTime<Utc>,
}

#[derive(Debug, Deserialize)]
pub struct UpdateReportStatusRequest {
    pub status: ReportStatus,
}

#[derive(Debug, Deserialize)]
pub struct ListReportsQuery {
    pub framework: Option<String>,
    pub status: Option<String>,
    pub limit: Option<usize>,
}

// ============================================================================
// Handler Functions
// ============================================================================

/// Generate compliance report
async fn generate_compliance_report(
    State(state): State<ComplianceState>,
    Json(request): Json<GenerateReportRequest>,
) -> GatewayResult<Json<GenerateReportResponse>> {
    let period = ReportPeriod {
        start_date: request.start_date,
        end_date: request.end_date,
        description: request.period_description,
    };

    let report_id = state.manager.generate_report(
        request.report_type,
        request.framework,
        period,
        "admin".to_string(), // Would extract from auth context
    ).await?;

    Ok(Json(GenerateReportResponse {
        report_id,
        status: ReportStatus::Draft,
        generated_at: Utc::now(),
    }))
}

/// List compliance reports
async fn list_compliance_reports(
    State(state): State<ComplianceState>,
    Query(query): Query<ListReportsQuery>,
) -> GatewayResult<Json<Vec<ComplianceReport>>> {
    let limit = query.limit.unwrap_or(50);
    let reports = state.manager.list_reports(limit).await;
    
    // Apply filters
    let filtered_reports = reports.into_iter()
        .filter(|r| {
            if let Some(ref framework_str) = query.framework {
                // Would implement framework string matching
                true
            } else {
                true
            }
        })
        .filter(|r| {
            if let Some(ref status_str) = query.status {
                // Would implement status string matching
                true
            } else {
                true
            }
        })
        .collect();
    
    Ok(Json(filtered_reports))
}

/// Get compliance report
async fn get_compliance_report(
    State(state): State<ComplianceState>,
    Path(report_id): Path<Uuid>,
) -> GatewayResult<Json<ComplianceReport>> {
    let report = state.manager.get_report(report_id).await
        .ok_or_else(|| GatewayError::not_found("Compliance report not found"))?;
    
    Ok(Json(report))
}

/// Update report status
async fn update_report_status(
    State(state): State<ComplianceState>,
    Path(report_id): Path<Uuid>,
    Json(request): Json<UpdateReportStatusRequest>,
) -> GatewayResult<StatusCode> {
    state.manager.update_report_status(report_id, request.status).await?;
    Ok(StatusCode::OK)
}

/// Get compliance dashboard
async fn get_compliance_dashboard(
    State(state): State<ComplianceState>,
) -> GatewayResult<Json<ComplianceDashboard>> {
    let dashboard = state.manager.get_dashboard_data().await?;
    Ok(Json(dashboard))
}

/// List compliance requirements
async fn list_compliance_requirements(
    State(_state): State<ComplianceState>,
) -> GatewayResult<Json<Vec<ComplianceRequirement>>> {
    // Would implement requirement listing
    Ok(Json(Vec::new()))
}

/// Get compliance requirement
async fn get_compliance_requirement(
    State(_state): State<ComplianceState>,
    Path(_requirement_id): Path<String>,
) -> GatewayResult<Json<ComplianceRequirement>> {
    // Would implement requirement retrieval
    Err(GatewayError::not_found("Requirement not found"))
}